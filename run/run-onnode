#!/bin/bash

##
## Run the system on the given context. TO be invoked on only MASTER node.
## Must be invoked after a proper `setuup-cluster` & `bld-system`!!!
##
## Usage: $ ./gnnman/run-onnode <Context> [Dataset] [#Lambdas]
##
## Arguments:
##      Context: Run which part of the system.
##      Dataset: Only needed for graphservers.
##

cd ${HOME}/gnn-lambda/

case $1 in
    #
    # Run graphserver.
    #
    "graph")
        if [[ $# -lt 2 ]]; then
            echo "Usage: run-onnode graph <dataset> [#lambdas]"
            exit
        fi

        GPORT=$( < ../gserverport )
        WPORT=$( < ../wserverport)

        DATAPORT=$( < ../dataport )
        CTRLPORT=$( < ../ctrlport )
        NODEPORT=$( < ../nodeport )
        WSERVERIP=$HOME/wserverip

        if [[ $# -lt 3 ]]; then
            NUM_LAMBDAS_FORWARD=$( < ../numlambdasforward )
            NUM_LAMBDAS_BACKWARD=$( < ../numlambdasbackward )
        else
            NUM_LAMBDAS_FORWARD=$3
            NUM_LAMBDAS_BACKWARD=$3
        fi

        let MODE=0
        let PIPELINE=0
        let NUM_EPOCHS=30
        for var in "$@"
        do
            if [ $var = "GPU" ] || [ $var = "gpu" ]; then
                if [ $MODE -eq 2 ]; then
                    echo "Mode already set to CPU. Ignoring GPU option"
                else
                    let MODE=1;
                    NUM_LAMBDAS_FORWARD=1
                    NUM_LAMBDAS_BACKWARD=1
                fi
            fi

            if [ $var = "CPU" ] || [ $var = "cpu" ]; then
                if [ $MODE -eq 1 ]; then
                    echo "Mode already set to GPU. Ignoring CPU option"
                else
                    let MODE=2;
                    NUM_LAMBDAS_FORWARD=1
                    NUM_LAMBDAS_BACKWARD=1
                fi
            fi

            if [ $var = "pipe" ] || [ $var = "PIPE" ]; then
                PIPELINE=1
            fi

            if [[ $var = --e=* ]] || [[ $var = --epochs=* ]]; then
                NUM_EPOCHS="${var#*=}"
            fi
        done

        # After processing args, check to see if GPU enables
        # If so, disable pipelining
        if [[ ($MODE -eq 1 || $MODE -eq 2)  &&  $PIPELINE -eq 1 ]]; then
            echo "GPU/CPU and pipeline cannot be used together. Disabling pipeline"
            PIPELINE=0
        fi

        MYPRIPFILE=${HOME}/myprip
        MYPUBIPFILE=${HOME}/mypubip
        DSHMACHINESFILE=${HOME}/dshmachines

        # Kill running graphservers.
        echo -e "\e[33;1mKilling existing 'graphserver' processes...\e[0m"
        dsh -f ${DSHMACHINESFILE} -c "killall -u $( whoami ) graphserver"

        # Count the machines.
        NDS=$( wc -l ${DSHMACHINESFILE} | cut -d" " -f1 )
        for i in $( seq 1 ${NDS} ); do
          DSHNODES[$i]=$( head -n $i ${DSHMACHINESFILE} | tail -n 1 )
        done

        # Choosing the dataset.
        if [[ -z $2 ]] || [[ ! -d /filepool/$2 ]]; then
            echo "Dataset '$2' is empty or not found under '/filepool' (at least on master node)."
            echo "Please prepare the dataset correctly."
            exit 1
        fi

        DATASET=/filepool/$2

        LAYERFILE=${HOME}/$2.config

        # Minor options.
        UNDIRECTED=0    # Currently are all directed graphs.
        COMP_THREADS=7  # Default values.
        COMM_THREADS=1

        # Increment the running mark.
        if [[ ! -f run/run-mark ]]; then
            touch run/run-mark
        fi
        RUN_MARK=$(( $( cat run/run-mark ) + 1 ))
        echo ${RUN_MARK} > run/run-mark
        echo -e "\e[33;1mRunning GRAPH servers with: [ MARK # ${RUN_MARK} ]...\e[0m"

        # Set logging file.
        LOGFILEDIR=${HOME}/logfiles
        mkdir -p ${LOGFILEDIR}
        LOGFILE=${LOGFILEDIR}/${RUN_MARK}.$2.log

        # Set temporary directory.
        TMPFILEDIR=${HOME}/tmpfiles
        dsh -f ${DSHMACHINESFILE} -c "rm -rf ${TMPFILEDIR} && mkdir -p ${TMPFILEDIR}"

        # Run the command on all dsh machines.
        DSH_COMMAND="./build/graphserver \
            --datasetdir ${DATASET}/parts_${NDS}/ \
            --featuresfile ${DATASET}/features.bsnap \
            --labelsfile ${DATASET}/labels.bsnap \
            --dshmachinesfile ${DSHMACHINESFILE} \
            --layerfile ${LAYERFILE} \
            --pubipfile ${MYPUBIPFILE} \
            --pripfile ${MYPRIPFILE} \
            --dataserverport ${GPORT} \
            --weightserverport ${WPORT} \
            --wserveripfile ${WSERVERIP} \
            --undirected ${UNDIRECTED} \
            --tmpdir=${TMPFILEDIR} \
            --cthreads ${COMP_THREADS} \
            --dthreads ${COMM_THREADS} \
            --dataport ${DATAPORT} \
            --ctrlport ${CTRLPORT} \
            --nodeport ${NODEPORT} \
            --numlambdasforward ${NUM_LAMBDAS_FORWARD} \
            --numlambdasbackward ${NUM_LAMBDAS_BACKWARD} \
            --numEpoch ${NUM_EPOCHS} \
            --validationFrequency 1 \
            --MODE ${MODE} \
            --pipeline ${PIPELINE}"
        echo ${DSH_COMMAND}
        dsh -f ${DSHMACHINESFILE} -c "cd ${HOME}/gnn-lambda && ${DSH_COMMAND}" 2>&1 | tee ${LOGFILE}


        # Gather the output files.
        OUTFILEDIR=${HOME}/outfiles/${RUN_MARK}.$2
        mkdir -p ${OUTFILEDIR}
        for i in $( seq 1 ${NDS} ); do
            scp -q ${DSHNODES[$i]}:${TMPFILEDIR}/output_* ${OUTFILEDIR}/
        done

        echo "Check the output results in \"~/outfiles/\" folder."
        echo "Check the running log under \"~/logfiles/\" folder."

        if [ -e ${OUTFILEDIR}/output_0 ]; then
          echo -e "\e[92;1mThis round of execution seems successful, congrats ;)\e[0m"
        else
          echo -e "\e[91;1mExecution fails (at least on this node), check the log file!\e[0m"
        fi
        ;;

    #
    # Run weightserver.
    #
    "weight")
        if [[ $# -lt 2 ]]; then
            echo "Usage: run-onnode weight [dataset]"
            exit
        fi

        WPORT=$( < ../wserverport )
        DATAPORT=$( < ../dataport )

        MYPRIPFILE=${HOME}/myprip
        DSHMACHINESFILE=${HOME}/dshmachines
        LAYERCONFIGFILE=${HOME}/$2.config

        # Kill running weightservers.
        echo -e "\e[33;1mKilling existing 'weightserver' processes...\e[0m"
        dsh -f ${DSHMACHINESFILE} -c "killall -u $( whoami ) weightserver"

        # Count the machines.
        NDS=$( wc -l ${DSHMACHINESFILE} | cut -d" " -f1 )
        for i in $( seq 1 ${NDS} ); do
          DSHNODES[$i]=$( head -n $i ${DSHMACHINESFILE} | tail -n 1 )
        done

        # Increment the running mark.
        if [[ ! -f run/run-mark ]]; then
            touch run/run-mark
        fi
        RUN_MARK=$(( $( cat run/run-mark ) + 1 ))
        echo ${RUN_MARK} > run/run-mark
        echo -e "\e[33;1mRunning WEIGHT servers with: [ MARK # ${RUN_MARK} ]...\e[0m"

        # Set temporary directory.
        TMPFILEDIR=${HOME}/tmpfiles
        dsh -f ${DSHMACHINESFILE} -c "rm -rf ${TMPFILEDIR} && mkdir -p ${TMPFILEDIR}"

        # Run weightserver on all dsh machines.
        DSH_COMMAND="./build/weightserver \
            ${DSHMACHINESFILE} \
            ${MYPRIPFILE} \
            ${DATAPORT} \
            ${WPORT} \
            ${LAYERCONFIGFILE} \
            ${TMPFILEDIR}"
        dsh -f ${DSHMACHINESFILE} -c "cd ${HOME}/gnn-lambda && ${DSH_COMMAND}"

        # Gather the output files.
        OUTFILEDIR=${HOME}/outfiles/${RUN_MARK}.weights
        mkdir -p ${OUTFILEDIR}
        for i in $( seq 1 ${NDS} ); do
            scp -q ${DSHNODES[$i]}:${TMPFILEDIR}/output_* ${OUTFILEDIR}/
        done

        echo "Check the output results in \"~/outfiles/\" folder."
        ;;

    *)
        echo "Must specify a valid context 'graph' / 'weight'"
        echo "Usage: ./run/run-onnode <Context>"
        exit 1
        ;;
esac
