import numpy as np
import os
from scipy.sparse import csr_matrix, identity

def load_data(base_dir, dataset, binary=True):
    print("Loading data...")
    if binary:
        feat_file = base_dir +"features.bsnap"
        label_file = base_dir +"labels.bsnap"
        graph_file = base_dir +"graph.bsnap"

        # Read in initial features.
        f = open(feat_file, 'rb')
        feat_dim = int.from_bytes(f.read(4), byteorder='little')
        print("Feature Dim: {}".format(feat_dim))
        input_feats = np.fromfile(f, dtype=np.float32).reshape(-1, feat_dim)
        # print(input_feats)

        num_vertices = input_feats.shape[0]

        # Read in target lables one-hot representation.
        f = open(label_file, 'rb')
        label_kind = int.from_bytes(f.read(4), byteorder='little')
        print("Label Kinds: {}".format(label_kind))
        target_labels = np.fromfile(f, dtype=np.int32)

        # Read in the graph and construct adjancency and degree matrix.
        f = open(graph_file, 'rb')
        vtx_type_size = int.from_bytes(f.read(4), byteorder='little')
        num_vtcs = int.from_bytes(f.read(4), byteorder='little')
        num_edges = int.from_bytes(f.read(8), byteorder='little')
        print("vtx type size: {}, num vtcs: {}, num edges: {}".format(vtx_type_size, num_vtcs, num_edges))
        edge_list = np.fromfile(f, dtype=np.int32).reshape(num_edges, 2)
        # Construct Adjacent Matrix with self-loop
        # adj_mat = np.identity(num_vertices)
        # for edge in edge_list:
        #     adj_mat[edge[1]][edge[0]] = 1

        # normed_deg_vec = 1 / np.sqrt(np.sum(adj_mat, axis=0, keepdims=True))
        # # Normalized A_hat matrix
        # A_hat = normed_deg_vec * adj_mat * normed_deg_vec.T
        adj_mat = identity(num_vertices, dtype=float).tolil()
        for edge in edge_list:
            adj_mat[edge[1], edge[0]] = 1
        normed_deg_vec = 1 / np.sqrt(np.sum(adj_mat, axis=0)).toarray()
        print(normed_deg_vec.type)
        A_hat = normed_deg_vec * adj_mat * normed_deg_vec.T
        print(A_hat)
        # np.save('ahat.npy', A_hat)

        print("Data Loaded. Adj Mat: " + str(A_hat.shape) + ", Feats: " +
            str(input_feats.shape))

        return A_hat, input_feats, target_labels
    else:
        if dataset == 'cora':
            feat_file = base_dir + dataset+".features"
            label_file = base_dir + dataset+".labels"
            graph_file = base_dir + dataset+".graph"
        else:
            feat_file = base_dir + "features"
            label_file = base_dir + "labels"
            graph_file = base_dir + dataset+".graph"

        # Read in initial features.
        input_feats = np.genfromtxt(feat_file, delimiter=',', dtype=float)
        # print(input_feats)

        num_vertices = input_feats.shape[0]

        # Read in target lables one-hot representation.
        target_labels = np.genfromtxt(label_file, dtype=int)

        # Read in the graph and construct adjancency and degree matrix.
        edge_list = np.genfromtxt(graph_file, dtype=int)
        # Construct Adjacent Matrix with self-loop
        adj_mat = np.identity(num_vertices)
        for edge in edge_list:
            adj_mat[edge[1]][edge[0]] = 1

        normed_deg_vec = 1 / np.sqrt(np.sum(adj_mat, axis=0, keepdims=True))
        # Normalized A_hat matrix
        A_hat = normed_deg_vec * adj_mat * normed_deg_vec.T

        print("Data Loaded. Adj Mat: " + str(A_hat.shape) + ", Feats: " +
            str(input_feats.shape))

        return A_hat, input_feats, target_labels


def load_weights(weights_file, layer_config):
    ''' Under construction. For loading weights and checking correctness '''
    # Weights generated by the weightserver.
    weights = [np.empty(shape=(layer_config[0], layer_config[1]), dtype=float),
               np.empty(shape=(layer_config[1], layer_config[2]), dtype=float)]
    with open(weights_file, "r") as fweights:
        mat_cnt, row_idx = -1, 0
        for line in fweights.readlines():
            line = line.strip()
            if line == "Matrix Dims: ({}, {})".format(layer_config[0], layer_config[1]):
                mat_cnt += 1
                row_idx = 0
            elif line == "Matrix Dims: ({}, {})".format(layer_config[1], layer_config[2]):
                mat_cnt += 1
                row_idx = 0
            elif line[:2] == "U:":
                continue
            elif len(line) > 0:
                weights[mat_cnt][row_idx] = list(map(float, line.split()))
                row_idx += 1
    print(weights[0].shape, weights[1].shape)
    # print(weights[0])
    # print(weights[1])
    return weights
